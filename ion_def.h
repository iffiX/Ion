//
// Created by iffi on 19-3-14.
//

#ifndef ION_DEF_H
#define ION_DEF_H

#include <fstream>
#include <cstddef>
#include <cstdlib>
#include <cstdint>
#include <cstdbool>
#include <loc/loc.h>
#include <ast/ast.h>
#define STRING_RAW            1
//#define STRING_UNICODE      2
//#define STRING_FORMAT       4
#define BYTES_RAW             1

#define ERROR                 (-1)

/**
 * The following enumeration codes are mantained by Bison
 * and defined in the parser code generated by Bison
 */
/*
    KW_FALSE,
    KW_NONE,
    KW_TRUE,
    KW_AND,
    KW_AS,
    KW_ASSERT,
    // KW_ASYNC,  // not supported
    // KW_AWAIT,  // not supported
    KW_BREAK,
    KW_CLASS,
    KW_CONTINUE,
    KW_DEF,
    KW_DEL,
    KW_ELIF,
    KW_ELSE,
    KW_EXCEPT,
    KW_FINALLY,
    KW_FOR,
    KW_FROM,
    KW_GLOBAL,
    KW_IF,
    KW_IMPORT,
    KW_IN,
    KW_IS,
    KW_LAMBDA,
    // KW_NONLOCAL, // not supported
    KW_NOT,
    KW_OR,
    KW_PASS,
    KW_RAISE,
    KW_RETURN,
    KW_TRY,
    KW_WHILE,
    KW_WITH,
    // KW_YIELD, // not supported

    IDENTIFIER
    NEWLINE
    INDENT
    DEDENT
    ENDMARKER

    NUM_INT
    NUM_FLOAT
    NUM_IMAG
    STRING
    BYTES

    DLM_PLUS,    // plus
    DLM_MINS,    // minus
    DLM_AST,     // asteroid *
    DLM_DAST,    // double asteroid **
    DLM_DIV,
    DLM_FDIV,    // floor division
    DLM_MOD,
    //DLM_AT,    // @: decorator / matrix multiplication
                // @ is not supported
    DLM_LSFT,    // left shift
    DLM_RSFT,    // right shift
    DLM_AND,
    DLM_OR,
    DLM_XOR,     // ^
    DLM_FLP,     // bit flip, ~
    DLM_LSS,     // <
    DLM_LSE,     // <=
    DLM_GTT,     // >
    DLM_GTE,     // >=
    DLM_EQT,     // ==
    DLM_NEQ,     // != or <>

    DLM_LPTS,   // left parentheses, (
    DLM_RPTS,   // right parentheses, )
    DLM_LBKT,   // left bracket, [
    DLM_RBKT,   // right bracket, ]
    DLM_LBC,    // left brace, {
    DLM_RBC,    // right brace, }
    DLM_CMM,    // comma, ,
    DLM_CLN,    // collon, :
    DLM_DOT,    // dot, .
    DLM_ELPS,   // ellipsis, ...
    DLM_SCLN,   // semicolon, ;
    DLM_EQL,    // equal, =
    DLM_RARW,   // right arrow, ->
    DLM_ADDE,   // add-equal, +=
    DLM_SUBE,   // sub-equal, -=
    DLM_MULE,   // multiply-equal, *=
    DLM_DIVE,   // divide-equal, /=
    DLM_FDVE,   // floor-divide-equal, //=
    DLM_MODE,   // mod-equal, %=
    //DLM_ATE,    // at-euqal, @= // not supported
    DLM_ANDE,   // and-equal, &=
    DLM_ORE,    // or-equal, |=
    DLM_XORE,   // xor-equal, ^=
    DLM_LSTE,   // left-shift-equal, <<=
    DLM_RSTE,   // right-shift-equal, >>=
    DLM_EXPE,   // exponent-equal, **=
*/

union Token {
    double float_val;
    double imag_val;    // only contains the imaginary part
    long long int int_val;
    char *str_val;
    uint8_t *bytes_val;
    char *id_val;
    ASTNode *node;
};

struct LexerState {
    /* buffer is used to assemble strings, bytes, messages etc. */
    std::list<void *> buffer_ptr;

    char string_quote = 0;
    char *string_buf_ptr;
    int string_begin_offset = 0;
    int flag_string_prefix = 0;

    char bytes_quote = 0;
    uint8_t *bytes_buf_ptr;
    int bytes_begin_offset = 0;
    int flag_bytes_prefix = 0;

    int flag_ex_join_line = 0; // Explicit line joining

    std::string err_msg;
    std::ifstream input;
    size_t major_offset = 0;    // row offset sum
    size_t minor_offset = 0;    // col offset
    Token *token;
};
typedef void* yyscan_t;
#endif //ION_DEF_H
